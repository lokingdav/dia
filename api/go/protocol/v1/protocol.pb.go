// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v6.31.1
// source: protocol/v1/protocol.proto

package protocolpb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Message types for the protocol
type MessageType int32

const (
	MessageType_MESSAGE_TYPE_UNSPECIFIED MessageType = 0
	MessageType_AKE_REQUEST              MessageType = 1
	MessageType_AKE_RESPONSE             MessageType = 2
	MessageType_AKE_COMPLETE             MessageType = 3
	MessageType_RUA_REQUEST              MessageType = 4
	MessageType_RUA_RESPONSE             MessageType = 5
	MessageType_HEARTBEAT                MessageType = 6
	MessageType_BYE                      MessageType = 7
)

// Enum value maps for MessageType.
var (
	MessageType_name = map[int32]string{
		0: "MESSAGE_TYPE_UNSPECIFIED",
		1: "AKE_REQUEST",
		2: "AKE_RESPONSE",
		3: "AKE_COMPLETE",
		4: "RUA_REQUEST",
		5: "RUA_RESPONSE",
		6: "HEARTBEAT",
		7: "BYE",
	}
	MessageType_value = map[string]int32{
		"MESSAGE_TYPE_UNSPECIFIED": 0,
		"AKE_REQUEST":              1,
		"AKE_RESPONSE":             2,
		"AKE_COMPLETE":             3,
		"RUA_REQUEST":              4,
		"RUA_RESPONSE":             5,
		"HEARTBEAT":                6,
		"BYE":                      7,
	}
)

func (x MessageType) Enum() *MessageType {
	p := new(MessageType)
	*p = x
	return p
}

func (x MessageType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MessageType) Descriptor() protoreflect.EnumDescriptor {
	return file_protocol_v1_protocol_proto_enumTypes[0].Descriptor()
}

func (MessageType) Type() protoreflect.EnumType {
	return &file_protocol_v1_protocol_proto_enumTypes[0]
}

func (x MessageType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MessageType.Descriptor instead.
func (MessageType) EnumDescriptor() ([]byte, []int) {
	return file_protocol_v1_protocol_proto_rawDescGZIP(), []int{0}
}

// ProtocolMessage is the envelope for all protocol messages
type ProtocolMessage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Type          MessageType            `protobuf:"varint,1,opt,name=type,proto3,enum=denseid.protocol.v1.MessageType" json:"type,omitempty"`
	SenderId      string                 `protobuf:"bytes,2,opt,name=sender_id,json=senderId,proto3" json:"sender_id,omitempty"`
	Topic         string                 `protobuf:"bytes,3,opt,name=topic,proto3" json:"topic,omitempty"`
	Payload       []byte                 `protobuf:"bytes,4,opt,name=payload,proto3" json:"payload,omitempty"` // Serialized AkeMessage or RuaMessage
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ProtocolMessage) Reset() {
	*x = ProtocolMessage{}
	mi := &file_protocol_v1_protocol_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ProtocolMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ProtocolMessage) ProtoMessage() {}

func (x *ProtocolMessage) ProtoReflect() protoreflect.Message {
	mi := &file_protocol_v1_protocol_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ProtocolMessage.ProtoReflect.Descriptor instead.
func (*ProtocolMessage) Descriptor() ([]byte, []int) {
	return file_protocol_v1_protocol_proto_rawDescGZIP(), []int{0}
}

func (x *ProtocolMessage) GetType() MessageType {
	if x != nil {
		return x.Type
	}
	return MessageType_MESSAGE_TYPE_UNSPECIFIED
}

func (x *ProtocolMessage) GetSenderId() string {
	if x != nil {
		return x.SenderId
	}
	return ""
}

func (x *ProtocolMessage) GetTopic() string {
	if x != nil {
		return x.Topic
	}
	return ""
}

func (x *ProtocolMessage) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

// AkeMessage is used for Authenticated Key Exchange
type AkeMessage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	DhPk          []byte                 `protobuf:"bytes,1,opt,name=dh_pk,json=dhPk,proto3" json:"dh_pk,omitempty"`    // DH public key (only in AkeResponse and AkeComplete)
	AmfPk         []byte                 `protobuf:"bytes,2,opt,name=amf_pk,json=amfPk,proto3" json:"amf_pk,omitempty"` // AMF public key for this party
	Expiration    []byte                 `protobuf:"bytes,3,opt,name=expiration,proto3" json:"expiration,omitempty"`    // Credential expiration timestamp
	Proof         []byte                 `protobuf:"bytes,4,opt,name=proof,proto3" json:"proof,omitempty"`              // ZK proof of enrollment
	PkePk         []byte                 `protobuf:"bytes,5,opt,name=pke_pk,json=pkePk,proto3" json:"pke_pk,omitempty"` // PKE public key for encryption
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AkeMessage) Reset() {
	*x = AkeMessage{}
	mi := &file_protocol_v1_protocol_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AkeMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AkeMessage) ProtoMessage() {}

func (x *AkeMessage) ProtoReflect() protoreflect.Message {
	mi := &file_protocol_v1_protocol_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AkeMessage.ProtoReflect.Descriptor instead.
func (*AkeMessage) Descriptor() ([]byte, []int) {
	return file_protocol_v1_protocol_proto_rawDescGZIP(), []int{1}
}

func (x *AkeMessage) GetDhPk() []byte {
	if x != nil {
		return x.DhPk
	}
	return nil
}

func (x *AkeMessage) GetAmfPk() []byte {
	if x != nil {
		return x.AmfPk
	}
	return nil
}

func (x *AkeMessage) GetExpiration() []byte {
	if x != nil {
		return x.Expiration
	}
	return nil
}

func (x *AkeMessage) GetProof() []byte {
	if x != nil {
		return x.Proof
	}
	return nil
}

func (x *AkeMessage) GetPkePk() []byte {
	if x != nil {
		return x.PkePk
	}
	return nil
}

// Rtu contains RTU information
type Rtu struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	AmfPk         []byte                 `protobuf:"bytes,1,opt,name=amf_pk,json=amfPk,proto3" json:"amf_pk,omitempty"` // AMF public key
	Expiration    []byte                 `protobuf:"bytes,2,opt,name=expiration,proto3" json:"expiration,omitempty"`    // RTU expiration
	Signature     []byte                 `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`      // Enrollment signature from RA
	Name          string                 `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`                // Display name
	PkePk         []byte                 `protobuf:"bytes,5,opt,name=pke_pk,json=pkePk,proto3" json:"pke_pk,omitempty"` // PKE public key for encryption
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Rtu) Reset() {
	*x = Rtu{}
	mi := &file_protocol_v1_protocol_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Rtu) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Rtu) ProtoMessage() {}

func (x *Rtu) ProtoReflect() protoreflect.Message {
	mi := &file_protocol_v1_protocol_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Rtu.ProtoReflect.Descriptor instead.
func (*Rtu) Descriptor() ([]byte, []int) {
	return file_protocol_v1_protocol_proto_rawDescGZIP(), []int{2}
}

func (x *Rtu) GetAmfPk() []byte {
	if x != nil {
		return x.AmfPk
	}
	return nil
}

func (x *Rtu) GetExpiration() []byte {
	if x != nil {
		return x.Expiration
	}
	return nil
}

func (x *Rtu) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *Rtu) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Rtu) GetPkePk() []byte {
	if x != nil {
		return x.PkePk
	}
	return nil
}

// RuaMessage is used for Rich User Authentication
type RuaMessage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	DhPk          []byte                 `protobuf:"bytes,1,opt,name=dh_pk,json=dhPk,proto3" json:"dh_pk,omitempty"` // DH public key for RUA phase
	Reason        string                 `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`         // Call reason
	Rtu           *Rtu                   `protobuf:"bytes,3,opt,name=rtu,proto3" json:"rtu,omitempty"`               // RTU info
	Tpc           string                 `protobuf:"bytes,4,opt,name=tpc,proto3" json:"tpc,omitempty"`
	Misc          []byte                 `protobuf:"bytes,5,opt,name=misc,proto3" json:"misc,omitempty"` // misc data
	Sigma         []byte                 `protobuf:"bytes,6,opt,name=sigma,proto3" json:"sigma,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RuaMessage) Reset() {
	*x = RuaMessage{}
	mi := &file_protocol_v1_protocol_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RuaMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RuaMessage) ProtoMessage() {}

func (x *RuaMessage) ProtoReflect() protoreflect.Message {
	mi := &file_protocol_v1_protocol_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RuaMessage.ProtoReflect.Descriptor instead.
func (*RuaMessage) Descriptor() ([]byte, []int) {
	return file_protocol_v1_protocol_proto_rawDescGZIP(), []int{3}
}

func (x *RuaMessage) GetDhPk() []byte {
	if x != nil {
		return x.DhPk
	}
	return nil
}

func (x *RuaMessage) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

func (x *RuaMessage) GetRtu() *Rtu {
	if x != nil {
		return x.Rtu
	}
	return nil
}

func (x *RuaMessage) GetTpc() string {
	if x != nil {
		return x.Tpc
	}
	return ""
}

func (x *RuaMessage) GetMisc() []byte {
	if x != nil {
		return x.Misc
	}
	return nil
}

func (x *RuaMessage) GetSigma() []byte {
	if x != nil {
		return x.Sigma
	}
	return nil
}

// DrHeader contains the Double Ratchet message header (Signal-compatible)
type DrHeader struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Dh            []byte                 `protobuf:"bytes,1,opt,name=dh,proto3" json:"dh,omitempty"`  // Current ratchet public key
	N             uint32                 `protobuf:"varint,2,opt,name=n,proto3" json:"n,omitempty"`   // Message number in current sending chain
	Pn            uint32                 `protobuf:"varint,3,opt,name=pn,proto3" json:"pn,omitempty"` // Number of messages in previous sending chain
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DrHeader) Reset() {
	*x = DrHeader{}
	mi := &file_protocol_v1_protocol_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DrHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DrHeader) ProtoMessage() {}

func (x *DrHeader) ProtoReflect() protoreflect.Message {
	mi := &file_protocol_v1_protocol_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DrHeader.ProtoReflect.Descriptor instead.
func (*DrHeader) Descriptor() ([]byte, []int) {
	return file_protocol_v1_protocol_proto_rawDescGZIP(), []int{4}
}

func (x *DrHeader) GetDh() []byte {
	if x != nil {
		return x.Dh
	}
	return nil
}

func (x *DrHeader) GetN() uint32 {
	if x != nil {
		return x.N
	}
	return 0
}

func (x *DrHeader) GetPn() uint32 {
	if x != nil {
		return x.Pn
	}
	return 0
}

// DrMessage is an encrypted message using the Double Ratchet protocol
type DrMessage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Header        *DrHeader              `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`         // Ratchet header
	Ciphertext    []byte                 `protobuf:"bytes,2,opt,name=ciphertext,proto3" json:"ciphertext,omitempty"` // Encrypted message content
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DrMessage) Reset() {
	*x = DrMessage{}
	mi := &file_protocol_v1_protocol_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DrMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DrMessage) ProtoMessage() {}

func (x *DrMessage) ProtoReflect() protoreflect.Message {
	mi := &file_protocol_v1_protocol_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DrMessage.ProtoReflect.Descriptor instead.
func (*DrMessage) Descriptor() ([]byte, []int) {
	return file_protocol_v1_protocol_proto_rawDescGZIP(), []int{5}
}

func (x *DrMessage) GetHeader() *DrHeader {
	if x != nil {
		return x.Header
	}
	return nil
}

func (x *DrMessage) GetCiphertext() []byte {
	if x != nil {
		return x.Ciphertext
	}
	return nil
}

var File_protocol_v1_protocol_proto protoreflect.FileDescriptor

const file_protocol_v1_protocol_proto_rawDesc = "" +
	"\n" +
	"\x1aprotocol/v1/protocol.proto\x12\x13denseid.protocol.v1\"\x94\x01\n" +
	"\x0fProtocolMessage\x124\n" +
	"\x04type\x18\x01 \x01(\x0e2 .denseid.protocol.v1.MessageTypeR\x04type\x12\x1b\n" +
	"\tsender_id\x18\x02 \x01(\tR\bsenderId\x12\x14\n" +
	"\x05topic\x18\x03 \x01(\tR\x05topic\x12\x18\n" +
	"\apayload\x18\x04 \x01(\fR\apayload\"\x85\x01\n" +
	"\n" +
	"AkeMessage\x12\x13\n" +
	"\x05dh_pk\x18\x01 \x01(\fR\x04dhPk\x12\x15\n" +
	"\x06amf_pk\x18\x02 \x01(\fR\x05amfPk\x12\x1e\n" +
	"\n" +
	"expiration\x18\x03 \x01(\fR\n" +
	"expiration\x12\x14\n" +
	"\x05proof\x18\x04 \x01(\fR\x05proof\x12\x15\n" +
	"\x06pke_pk\x18\x05 \x01(\fR\x05pkePk\"\x85\x01\n" +
	"\x03Rtu\x12\x15\n" +
	"\x06amf_pk\x18\x01 \x01(\fR\x05amfPk\x12\x1e\n" +
	"\n" +
	"expiration\x18\x02 \x01(\fR\n" +
	"expiration\x12\x1c\n" +
	"\tsignature\x18\x03 \x01(\fR\tsignature\x12\x12\n" +
	"\x04name\x18\x04 \x01(\tR\x04name\x12\x15\n" +
	"\x06pke_pk\x18\x05 \x01(\fR\x05pkePk\"\xa1\x01\n" +
	"\n" +
	"RuaMessage\x12\x13\n" +
	"\x05dh_pk\x18\x01 \x01(\fR\x04dhPk\x12\x16\n" +
	"\x06reason\x18\x02 \x01(\tR\x06reason\x12*\n" +
	"\x03rtu\x18\x03 \x01(\v2\x18.denseid.protocol.v1.RtuR\x03rtu\x12\x10\n" +
	"\x03tpc\x18\x04 \x01(\tR\x03tpc\x12\x12\n" +
	"\x04misc\x18\x05 \x01(\fR\x04misc\x12\x14\n" +
	"\x05sigma\x18\x06 \x01(\fR\x05sigma\"8\n" +
	"\bDrHeader\x12\x0e\n" +
	"\x02dh\x18\x01 \x01(\fR\x02dh\x12\f\n" +
	"\x01n\x18\x02 \x01(\rR\x01n\x12\x0e\n" +
	"\x02pn\x18\x03 \x01(\rR\x02pn\"b\n" +
	"\tDrMessage\x125\n" +
	"\x06header\x18\x01 \x01(\v2\x1d.denseid.protocol.v1.DrHeaderR\x06header\x12\x1e\n" +
	"\n" +
	"ciphertext\x18\x02 \x01(\fR\n" +
	"ciphertext*\x9b\x01\n" +
	"\vMessageType\x12\x1c\n" +
	"\x18MESSAGE_TYPE_UNSPECIFIED\x10\x00\x12\x0f\n" +
	"\vAKE_REQUEST\x10\x01\x12\x10\n" +
	"\fAKE_RESPONSE\x10\x02\x12\x10\n" +
	"\fAKE_COMPLETE\x10\x03\x12\x0f\n" +
	"\vRUA_REQUEST\x10\x04\x12\x10\n" +
	"\fRUA_RESPONSE\x10\x05\x12\r\n" +
	"\tHEARTBEAT\x10\x06\x12\a\n" +
	"\x03BYE\x10\aBAZ?github.com/dense-identity/denseid/api/go/protocol/v1;protocolpbb\x06proto3"

var (
	file_protocol_v1_protocol_proto_rawDescOnce sync.Once
	file_protocol_v1_protocol_proto_rawDescData []byte
)

func file_protocol_v1_protocol_proto_rawDescGZIP() []byte {
	file_protocol_v1_protocol_proto_rawDescOnce.Do(func() {
		file_protocol_v1_protocol_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_protocol_v1_protocol_proto_rawDesc), len(file_protocol_v1_protocol_proto_rawDesc)))
	})
	return file_protocol_v1_protocol_proto_rawDescData
}

var file_protocol_v1_protocol_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_protocol_v1_protocol_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_protocol_v1_protocol_proto_goTypes = []any{
	(MessageType)(0),        // 0: denseid.protocol.v1.MessageType
	(*ProtocolMessage)(nil), // 1: denseid.protocol.v1.ProtocolMessage
	(*AkeMessage)(nil),      // 2: denseid.protocol.v1.AkeMessage
	(*Rtu)(nil),             // 3: denseid.protocol.v1.Rtu
	(*RuaMessage)(nil),      // 4: denseid.protocol.v1.RuaMessage
	(*DrHeader)(nil),        // 5: denseid.protocol.v1.DrHeader
	(*DrMessage)(nil),       // 6: denseid.protocol.v1.DrMessage
}
var file_protocol_v1_protocol_proto_depIdxs = []int32{
	0, // 0: denseid.protocol.v1.ProtocolMessage.type:type_name -> denseid.protocol.v1.MessageType
	3, // 1: denseid.protocol.v1.RuaMessage.rtu:type_name -> denseid.protocol.v1.Rtu
	5, // 2: denseid.protocol.v1.DrMessage.header:type_name -> denseid.protocol.v1.DrHeader
	3, // [3:3] is the sub-list for method output_type
	3, // [3:3] is the sub-list for method input_type
	3, // [3:3] is the sub-list for extension type_name
	3, // [3:3] is the sub-list for extension extendee
	0, // [0:3] is the sub-list for field type_name
}

func init() { file_protocol_v1_protocol_proto_init() }
func file_protocol_v1_protocol_proto_init() {
	if File_protocol_v1_protocol_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_protocol_v1_protocol_proto_rawDesc), len(file_protocol_v1_protocol_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   6,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_protocol_v1_protocol_proto_goTypes,
		DependencyIndexes: file_protocol_v1_protocol_proto_depIdxs,
		EnumInfos:         file_protocol_v1_protocol_proto_enumTypes,
		MessageInfos:      file_protocol_v1_protocol_proto_msgTypes,
	}.Build()
	File_protocol_v1_protocol_proto = out.File
	file_protocol_v1_protocol_proto_goTypes = nil
	file_protocol_v1_protocol_proto_depIdxs = nil
}
